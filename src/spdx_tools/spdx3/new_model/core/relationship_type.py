# SPDX-License-Identifier: Apache-2.0
#
# This file was auto-generated by dev/gen_python_model_from_spec.py
# Do not manually edit!
# flake8: noqa

from enum import Enum, auto

from beartype.typing import Optional


class RelationshipType(Enum):
    """
    Provides information about the relationship between two Elements. For example, you can represent a relationship
    between two different Files, between a Package and a File, between two Packages, or between one SPDXDocument and
    another SPDXDocument.
    """

    AFFECTS = auto()
    """
    (Security/VEX) Designates one or more elements as affected by a vulnerability
    """
    AMENDS = auto()
    """
    Every `to` Element amends the `from` Element
    """
    ANCESTOR = auto()
    """
    Every `to` Element is an ancestor of the `from` Element
    """
    AVAILABLE_FROM = auto()
    """
    This relationship is used to identify additional suppliers where an artifact is available from.
    """
    BUILD_DEPENDENCY = auto()
    """
    Every `to` Element is a build dependency of the `from` Element
    """
    BUILD_TOOL = auto()
    """
    Build tool used to build an Element. This may be used to describe the build tool of a Build instance
    """
    COORDINATED_BY = auto()
    """
    (Security) Used to identify the vendor, researcher, or consumer agent performing coordination for a vulnerability
    """
    CONTAINS = auto()
    """
    Every `to` Element is contained by the `from` Element
    """
    CONFIG_OF = auto()
    """
    (Build) Configuration information applied to an Element instance during a LifeycleScopeType period. Example: Build
    configuration of the build instance
    """
    COPY = auto()
    """
    Every `to` Element is a copy of the `from` Element
    """
    DATA_FILE = auto()
    """
    Every `to` Element is a data file related to the the `from` Element
    """
    DEPENDENCY_MANIFEST = auto()
    """
    Every `to` Element is manifest file containing dependency information related to the `from` Element
    """
    DEPENDS_ON = auto()
    """
    Every `to` Element is a dependecy of the `from` Element
    """
    DESCENDANT = auto()
    """
    This relationship may be used to describe child builds of a Build instance.
    """
    DESCRIBES = auto()
    """
    Every `to` Element is described by the `from` Element. This can be used to denote the root(s) of a tree of elements
    contained in an SBOM.
    """
    DEV_DEPENDENCY = auto()
    """
    Every `to` Element is a development dependency for the `from` Element
    """
    DEV_TOOL = auto()
    """
    Every `to` Element is a development tool for the `from` Element
    """
    DISTRIBUTION_ARTIFACT = auto()
    """
    Every `to` Element is an artifact intended for distribution of the `from` Element (e.g. an RPM or archive file)
    """
    DOCUMENTATION = auto()
    """
    Every `to` Element is documentation for the `from` Element
    """
    DOES_NOT_AFFECT = auto()
    """
    (Security/VEX) Specifies a vulnerability has no impact on one or more elements
    """
    DYNAMIC_LINK = auto()
    """
    Every `to` Element is dynamically linked to the `from` Element
    """
    EXAMPLE = auto()
    """
    Every `to` Element is an example for the `from` Element
    """
    EVIDENCE_FOR = auto()
    """
    (Dataset) Every `to` Element is can be considered as evidence for the `from` Element
    """
    EXPANDED_FROM_ARCHIVE = auto()
    """
    Every `to` Element is an artifact expanded from the `from` archive file
    """
    EXPLOIT_CREATED_BY = auto()
    """
    (Security) Designates an agent has created an exploit against a vulnerability
    """
    FILE_ADDED = auto()
    """
    Every `to` Element is is a file added to the `from` Element
    """
    FILE_DELETED = auto()
    """
    Every `to` Element is a file deleted from the `from` Element
    """
    FILE_MODIFIED = auto()
    """
    Every `to` Element is a modification of the `from` Element
    """
    FIXED_BY = auto()
    """
    (Security) Designates a vulnerability has been fixed by an agent
    """
    FIXED_IN = auto()
    """
    (Security/VEX) A vulnerability has been fixed in one or more elements
    """
    FOUND_BY = auto()
    """
    (Security) Designates an agent was the original discoverer of a security vulnerability
    """
    GENERATES = auto()
    """
    Every `to` Element is generated from the `from` Element
    """
    HAS_ASSESSMENT_FOR = auto()
    """
    (Security) Relates a Vulnerability and an Element with a security assessment.
    """
    HAS_ASSOCIATED_VULNERABILITY = auto()
    """
    (Security) Used to associate a security vulnerability with a software artifact
    """
    HOST_OF = auto()
    """
    (Build) The`from` Element in which every instance of the `to` Element during a LifecycleScopeType period runs on.
    Example: host that the build runs on for an element.
    """
    INPUT_OF = auto()
    """
    (Build) Input to the Element instance during a LifecycleScopeType period. Example: input to the build instance for
    an element.
    """
    INVOKED_BY = auto()
    """
    (Build) Every`to` Agent that invoked a `from` Element instance during a LifecycleScopeType period. Example: Agent
    that invoked the build for an element
    """
    METAFILE = auto()
    """
    Every `to` Element is is a file containing metadata about the `from` Element
    """
    ON_BEHALF_OF = auto()
    """
    (Build) Every `to` Agent acting on behalf of another `from` Agent during a LifecycleScopeType period
    """
    OPTIONAL_COMPONENT = auto()
    """
    Every `to` Element is an optional component of the `from` Element
    """
    OPTIONAL_DEPENDENCY = auto()
    """
    Every `to` Element is an optional dependency of the `from` Element
    """
    OTHER = auto()
    """
    Every `to` Element is related to the `from` Element where the relationship type is not described by any of the SPDX
    relationhip types
    """
    OUTPUT_OF = auto()
    """
    (Build) `from` Element that is output `to` the Element instance during a LifecycleScopeType period. Example: output
    of the build instance
    """
    PACKAGES = auto()
    """
    Every `to` Element is a packaged form of the `from` Element
    """
    PATCH = auto()
    """
    Every `to` Element is a patch for the `from` Element
    """
    PREREQUISITE = auto()
    """
    Every `to` Element is a prerequisite of the `from` Element
    """
    PROVIDED_DEPENDENCY = auto()
    """
    Every `to` Element is a dependency not included in the distributed artifact but is assumed to be provided the
    `from` Element
    """
    PUBLISHED_BY = auto()
    """
    (Security) Designates the agent that made a vulnerability record available for public use or reference
    """
    REPORTED_BY = auto()
    """
    (Security) Designates the agent that first reported a vulnerability to the project, vendor, or tracking database
    for formal identification
    """
    REPUBLISHED_BY = auto()
    """
    (Security) Designates the agent that tracked, aggregated, and/or enriched vulnerability details to improve context
    (i.e. NVD)
    """
    REQUIREMENT_FOR = auto()
    """
    Every `to` Element is required for the `from` Element
    """
    RUNTIME_DEPENDENCY = auto()
    """
    Every `to` Element is a runtime dependency for the `from` Element
    """
    SPECIFICATION_FOR = auto()
    """
    Every `to` Element is a specification for the `from` Element
    """
    STATIC_LINK = auto()
    """
    Every `to` Element is statically linked to the `from` Element
    """
    TEST = auto()
    """
    Every `to` Element is a test artifact for the `from` Element
    """
    TEST_CASE = auto()
    """
    Every `to` Element is a test case for the `from` Element
    """
    TEST_DEPENDENCY = auto()
    """
    Every `to` Element is a test dependency for the `from` Element
    """
    TEST_TOOL = auto()
    """
    Every `to` Element is a test tool for the `from` Element
    """
    TESTED_ON = auto()
    """
    (AI, Dataset) The `from` Element has been tested on the `to` Element
    """
    TRAINED_ON = auto()
    """
    (AI, Dataset) The `from` Element has been trained by the `to` Element(s)
    """
    UNDER_INVESTIGATION_FOR = auto()
    """
    (Security/VEX) The impact of a vulnerability is being investigated
    """
    VARIANT = auto()
    """
    Every `to` Element is a variant the `from` Element
    """

    def __str__(self) -> str:
        if self == RelationshipType.AFFECTS:
            return "affects"
        if self == RelationshipType.AMENDS:
            return "amends"
        if self == RelationshipType.ANCESTOR:
            return "ancestor"
        if self == RelationshipType.AVAILABLE_FROM:
            return "availableFrom"
        if self == RelationshipType.BUILD_DEPENDENCY:
            return "buildDependency"
        if self == RelationshipType.BUILD_TOOL:
            return "buildTool"
        if self == RelationshipType.COORDINATED_BY:
            return "coordinatedBy"
        if self == RelationshipType.CONTAINS:
            return "contains"
        if self == RelationshipType.CONFIG_OF:
            return "configOf"
        if self == RelationshipType.COPY:
            return "copy"
        if self == RelationshipType.DATA_FILE:
            return "dataFile"
        if self == RelationshipType.DEPENDENCY_MANIFEST:
            return "dependencyManifest"
        if self == RelationshipType.DEPENDS_ON:
            return "dependsOn"
        if self == RelationshipType.DESCENDANT:
            return "descendant"
        if self == RelationshipType.DESCRIBES:
            return "describes"
        if self == RelationshipType.DEV_DEPENDENCY:
            return "devDependency"
        if self == RelationshipType.DEV_TOOL:
            return "devTool"
        if self == RelationshipType.DISTRIBUTION_ARTIFACT:
            return "distributionArtifact"
        if self == RelationshipType.DOCUMENTATION:
            return "documentation"
        if self == RelationshipType.DOES_NOT_AFFECT:
            return "doesNotAffect"
        if self == RelationshipType.DYNAMIC_LINK:
            return "dynamicLink"
        if self == RelationshipType.EXAMPLE:
            return "example"
        if self == RelationshipType.EVIDENCE_FOR:
            return "evidenceFor"
        if self == RelationshipType.EXPANDED_FROM_ARCHIVE:
            return "expandedFromArchive"
        if self == RelationshipType.EXPLOIT_CREATED_BY:
            return "exploitCreatedBy"
        if self == RelationshipType.FILE_ADDED:
            return "fileAdded"
        if self == RelationshipType.FILE_DELETED:
            return "fileDeleted"
        if self == RelationshipType.FILE_MODIFIED:
            return "fileModified"
        if self == RelationshipType.FIXED_BY:
            return "fixedBy"
        if self == RelationshipType.FIXED_IN:
            return "fixedIn"
        if self == RelationshipType.FOUND_BY:
            return "foundBy"
        if self == RelationshipType.GENERATES:
            return "generates"
        if self == RelationshipType.HAS_ASSESSMENT_FOR:
            return "hasAssessmentFor"
        if self == RelationshipType.HAS_ASSOCIATED_VULNERABILITY:
            return "hasAssociatedVulnerability"
        if self == RelationshipType.HOST_OF:
            return "hostOf"
        if self == RelationshipType.INPUT_OF:
            return "inputOf"
        if self == RelationshipType.INVOKED_BY:
            return "invokedBy"
        if self == RelationshipType.METAFILE:
            return "metafile"
        if self == RelationshipType.ON_BEHALF_OF:
            return "onBehalfOf"
        if self == RelationshipType.OPTIONAL_COMPONENT:
            return "optionalComponent"
        if self == RelationshipType.OPTIONAL_DEPENDENCY:
            return "optionalDependency"
        if self == RelationshipType.OTHER:
            return "other"
        if self == RelationshipType.OUTPUT_OF:
            return "outputOf"
        if self == RelationshipType.PACKAGES:
            return "packages"
        if self == RelationshipType.PATCH:
            return "patch"
        if self == RelationshipType.PREREQUISITE:
            return "prerequisite"
        if self == RelationshipType.PROVIDED_DEPENDENCY:
            return "providedDependency"
        if self == RelationshipType.PUBLISHED_BY:
            return "publishedBy"
        if self == RelationshipType.REPORTED_BY:
            return "reportedBy"
        if self == RelationshipType.REPUBLISHED_BY:
            return "republishedBy"
        if self == RelationshipType.REQUIREMENT_FOR:
            return "requirementFor"
        if self == RelationshipType.RUNTIME_DEPENDENCY:
            return "runtimeDependency"
        if self == RelationshipType.SPECIFICATION_FOR:
            return "specificationFor"
        if self == RelationshipType.STATIC_LINK:
            return "staticLink"
        if self == RelationshipType.TEST:
            return "test"
        if self == RelationshipType.TEST_CASE:
            return "testCase"
        if self == RelationshipType.TEST_DEPENDENCY:
            return "testDependency"
        if self == RelationshipType.TEST_TOOL:
            return "testTool"
        if self == RelationshipType.TESTED_ON:
            return "testedOn"
        if self == RelationshipType.TRAINED_ON:
            return "trainedOn"
        if self == RelationshipType.UNDER_INVESTIGATION_FOR:
            return "underInvestigationFor"
        if self == RelationshipType.VARIANT:
            return "variant"
        return "unknown"

    @staticmethod
    def from_str(value: str) -> Optional["RelationshipType"]:
        if value == "affects":
            return RelationshipType.AFFECTS
        if value == "amends":
            return RelationshipType.AMENDS
        if value == "ancestor":
            return RelationshipType.ANCESTOR
        if value == "availableFrom":
            return RelationshipType.AVAILABLE_FROM
        if value == "buildDependency":
            return RelationshipType.BUILD_DEPENDENCY
        if value == "buildTool":
            return RelationshipType.BUILD_TOOL
        if value == "coordinatedBy":
            return RelationshipType.COORDINATED_BY
        if value == "contains":
            return RelationshipType.CONTAINS
        if value == "configOf":
            return RelationshipType.CONFIG_OF
        if value == "copy":
            return RelationshipType.COPY
        if value == "dataFile":
            return RelationshipType.DATA_FILE
        if value == "dependencyManifest":
            return RelationshipType.DEPENDENCY_MANIFEST
        if value == "dependsOn":
            return RelationshipType.DEPENDS_ON
        if value == "descendant":
            return RelationshipType.DESCENDANT
        if value == "describes":
            return RelationshipType.DESCRIBES
        if value == "devDependency":
            return RelationshipType.DEV_DEPENDENCY
        if value == "devTool":
            return RelationshipType.DEV_TOOL
        if value == "distributionArtifact":
            return RelationshipType.DISTRIBUTION_ARTIFACT
        if value == "documentation":
            return RelationshipType.DOCUMENTATION
        if value == "doesNotAffect":
            return RelationshipType.DOES_NOT_AFFECT
        if value == "dynamicLink":
            return RelationshipType.DYNAMIC_LINK
        if value == "example":
            return RelationshipType.EXAMPLE
        if value == "evidenceFor":
            return RelationshipType.EVIDENCE_FOR
        if value == "expandedFromArchive":
            return RelationshipType.EXPANDED_FROM_ARCHIVE
        if value == "exploitCreatedBy":
            return RelationshipType.EXPLOIT_CREATED_BY
        if value == "fileAdded":
            return RelationshipType.FILE_ADDED
        if value == "fileDeleted":
            return RelationshipType.FILE_DELETED
        if value == "fileModified":
            return RelationshipType.FILE_MODIFIED
        if value == "fixedBy":
            return RelationshipType.FIXED_BY
        if value == "fixedIn":
            return RelationshipType.FIXED_IN
        if value == "foundBy":
            return RelationshipType.FOUND_BY
        if value == "generates":
            return RelationshipType.GENERATES
        if value == "hasAssessmentFor":
            return RelationshipType.HAS_ASSESSMENT_FOR
        if value == "hasAssociatedVulnerability":
            return RelationshipType.HAS_ASSOCIATED_VULNERABILITY
        if value == "hostOf":
            return RelationshipType.HOST_OF
        if value == "inputOf":
            return RelationshipType.INPUT_OF
        if value == "invokedBy":
            return RelationshipType.INVOKED_BY
        if value == "metafile":
            return RelationshipType.METAFILE
        if value == "onBehalfOf":
            return RelationshipType.ON_BEHALF_OF
        if value == "optionalComponent":
            return RelationshipType.OPTIONAL_COMPONENT
        if value == "optionalDependency":
            return RelationshipType.OPTIONAL_DEPENDENCY
        if value == "other":
            return RelationshipType.OTHER
        if value == "outputOf":
            return RelationshipType.OUTPUT_OF
        if value == "packages":
            return RelationshipType.PACKAGES
        if value == "patch":
            return RelationshipType.PATCH
        if value == "prerequisite":
            return RelationshipType.PREREQUISITE
        if value == "providedDependency":
            return RelationshipType.PROVIDED_DEPENDENCY
        if value == "publishedBy":
            return RelationshipType.PUBLISHED_BY
        if value == "reportedBy":
            return RelationshipType.REPORTED_BY
        if value == "republishedBy":
            return RelationshipType.REPUBLISHED_BY
        if value == "requirementFor":
            return RelationshipType.REQUIREMENT_FOR
        if value == "runtimeDependency":
            return RelationshipType.RUNTIME_DEPENDENCY
        if value == "specificationFor":
            return RelationshipType.SPECIFICATION_FOR
        if value == "staticLink":
            return RelationshipType.STATIC_LINK
        if value == "test":
            return RelationshipType.TEST
        if value == "testCase":
            return RelationshipType.TEST_CASE
        if value == "testDependency":
            return RelationshipType.TEST_DEPENDENCY
        if value == "testTool":
            return RelationshipType.TEST_TOOL
        if value == "testedOn":
            return RelationshipType.TESTED_ON
        if value == "trainedOn":
            return RelationshipType.TRAINED_ON
        if value == "underInvestigationFor":
            return RelationshipType.UNDER_INVESTIGATION_FOR
        if value == "variant":
            return RelationshipType.VARIANT
        return None
