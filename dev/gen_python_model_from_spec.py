# SPDX-FileCopyrightText: 2023 spdx contributors
#
# SPDX-License-Identifier: Apache-2.0

"""
Auto-generates the python model representation from the SPDX3 model spec.

Usage: fetch a fresh copy of the spdx-3-model and the spec-parser, then generate a json dump of the model with
the spec-parser:

    python main.py --json-dump ../spdx-3-model/model

Copy the generated `model_dump.json` in `md_generated` next to this file, then run it:

    python gen_python_model_from_spec.py

Commit resulting changes.

Note: needs an additional dependency for proper formatting of docstrings:

    pip install mistletoe
"""

import json
import os.path
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

import mistletoe
from mistletoe.markdown_renderer import MarkdownRenderer

from spdx_tools.spdx.casing_tools import camel_case_to_snake_case

FILE_HEADER = """# SPDX-License-Identifier: Apache-2.0
#
# This file was auto-generated by dev/gen_python_model_from_spec.py
# Do not manually edit!

"""

VOCAB_FILE = FILE_HEADER + """from beartype.typing import Optional
from enum import Enum, auto


class {typename}(Enum):{docstring}

{values}

    def __str__(self) -> str:
{values_to_str}
        return "unknown"

    @staticmethod
    def from_str(value: str) -> Optional['{typename}']:
{str_to_values}
        return None
"""

VOCAB_ENTRY = "    {value} = auto(){docstring}"

VOCAB_VALUE_TO_STR = "        if self == {typename}.{python_value}:\n            return \"{str_value}\""

VOCAB_STR_TO_VALUE = "        if value == \"{str_value}\":\n            return {typename}.{python_value}"

CLS_FILE = FILE_HEADER + """{imports}
from spdx_tools.common.typing.dataclass_with_properties import dataclass_with_properties


@dataclass_with_properties
class {typename}({parent}):{docstring}
{properties}
{constructor}"""

CLS_IMPORTS = "from {module} import {types}\n"

CLS_PROP = "    {prop_name}: {prop_type}{default}{docstring}\n"

CLS_INIT = """    def __init__(
        self,{arguments}
    ):{remaps}
        check_types_and_set_values(self, locals())
"""
CLS_INIT_ARG = "\n        {prop_name}: {prop_type},"
CLS_INIT_ARG_OPT = "\n        {prop_name}: {prop_type} = None,"
CLS_INIT_REMAP = "\n        {prop_name} = {default} if {prop_name} is None else {prop_name}"

CLS_INIT_ABSTRACT = """    @abstractmethod
    def __init__(self):
        pass
"""

SPECIAL_TYPE_MAPPINGS: dict[str, tuple[str, Optional[str]]] = {
    "Core/DateTime": ("datetime", "datetime"),
    "Core/Extension": ("str", None),
    "Core/MediaType": ("str", None),
    "Core/SemVer": ("Version", "semantic_version"),
    "xsd:anyURI": ("str", None),
    "xsd:boolean": ("bool", None),
    "xsd:datetime": ("datetime", "datetime"),
    "xsd:decimal": ("float", None),
    "xsd:double": ("float", None),
    "xsd:float": ("float", None),
    "xsd:int": ("int", None),
    "xsd:integer": ("int", None),
    "xsd:negativeInteger": ("int", None),
    "xsd:nonNegativeInteger": ("int", None),
    "xsd:nonPositiveInteger": ("int", None),
    "xsd:positiveInteger": ("int", None),
    "xsd:string": ("str", None),
}

SPECIAL_PROPTYPE_MAPPINGS: dict[str, tuple[str, Optional[str]]] = {
    # for the moment, we replace Element and Agent references with string references to their ID
    # otherwise, there is a cyclic dependency between CreationInfo and Agent that is problematic to deal with
    "Core/Agent": ("str", None),
    "Core/Element": ("str", None),
}

# TODO: use the actual model package path rather than a separate path
output_dir = os.path.join(os.path.dirname(__file__), "../src/spdx_tools/spdx3/new_model")


def prop_name_to_python(prop_name: str):
    special_cases = {"from": "from_element", "homePage": "homepage"}
    _, prop_name = split_qualified_name(prop_name)
    if prop_name in special_cases:
        return special_cases[prop_name]
    return camel_case_to_snake_case(prop_name)


def namespace_name_to_python(namespace_name: str):
    special_cases = {"AI": "ai"}
    if namespace_name in special_cases:
        return special_cases[namespace_name]
    return camel_case_to_snake_case(namespace_name)


def get_file_path(typename: str, namespace: str) -> str:
    namespace = namespace_name_to_python(namespace)
    typename = camel_case_to_snake_case(typename) if typename != "AIPackage" else "ai_package"
    return os.path.join(output_dir, namespace, f"{typename}.py")


def get_python_docstring(description: Optional[str], indent: int) -> str:
    if not description:
        return ""

    line_length = 120 - indent
    with MarkdownRenderer(max_line_length=line_length) as renderer:
        text = renderer.render(mistletoe.Document(description))
    text = '\n"""\n' + text + '"""'
    return textwrap.indent(text, ' ' * indent)


def get_qualified_name(name: str, namespace: str):
    if name.startswith('/'):
        name = name[1:]
    if name.startswith("xsd:"):
        return name
    if '/' in name:
        return name
    return f"{namespace}/{name}"


def split_qualified_name(typename: str) -> tuple[str, str]:
    if '/' not in typename:
        return "", typename
    namespace, _, typename = typename.partition('/')
    return namespace, typename


def to_python_type(typename: str) -> str:
    if typename in SPECIAL_TYPE_MAPPINGS:
        return SPECIAL_TYPE_MAPPINGS[typename][0]
    if typename.startswith("xsd:"):
        return "str"
    _, typename = split_qualified_name(typename)
    return typename


def extract_parent_type(cls: dict, namespace: str) -> Optional[str]:
    parent_class = cls["metadata"].get("SubclassOf") or "none"
    if parent_class == "none":
        return None
    return get_qualified_name(parent_class, namespace)


@dataclass
class Property:
    name: str
    type: str
    optional: bool
    is_list: bool
    inherited: bool

    def get_python_type(self) -> str:
        if self.type == "Core/DictionaryEntry":
            return "Dict[str, Optional[str]]"
        if self.type in SPECIAL_PROPTYPE_MAPPINGS:
            prop_type = SPECIAL_PROPTYPE_MAPPINGS[self.type][0]
        else:
            prop_type = to_python_type(self.type)
        if self.is_list:
            prop_type = f"List[{prop_type}]"
        elif self.optional:
            prop_type = f"Optional[{prop_type}]"
        return prop_type


class GenClassFromSpec:
    cls: dict
    model: dict

    typename: str
    namespace: str
    filename: str
    file_path: str
    parent_class: str
    docstring: str
    # module -> types
    imports: dict[str, set[str]]
    props: list[Property]

    def __init__(self, cls: dict, namespace: str, model: dict):
        self.cls = cls
        self.namespace = namespace
        self.model = model
        self.imports = dict()
        self.props = list()

        self.typename = cls["metadata"]["name"]
        self.filename = camel_case_to_snake_case(self.typename)
        parent_class = extract_parent_type(cls, namespace)
        if not parent_class:
            self.parent_class = "ABC"
            self._add_import("abc", "ABC")
        else:
            self.parent_class = to_python_type(parent_class)
            self._import_spdx_type(parent_class)
        self.docstring = get_python_docstring(cls["description"], 4)
        self.file_path = get_file_path(self.typename, namespace)

        self._collect_props(self.cls, self.namespace, False)

    def _add_import(self, module: str, typename: str):
        if module not in self.imports:
            self.imports[module] = set()
        self.imports[module].add(typename)

    def _import_spdx_type(self, typename: str):
        if typename in SPECIAL_TYPE_MAPPINGS:
            import_type, import_module = SPECIAL_TYPE_MAPPINGS[typename]
            if import_module:
                self._add_import(import_module, import_type)
            return
        if typename.startswith("xsd:"):
            return
        namespace, typename = split_qualified_name(typename)
        namespace = f"..{namespace_name_to_python(namespace)}"
        self._add_import(namespace, typename)

    def _collect_props(self, cls: dict, namespace: str, is_parent: bool):
        parent = extract_parent_type(cls, namespace)
        if parent:
            parent_namespace, parent_class = split_qualified_name(parent)
            if parent_namespace in self.model and parent_class in self.model[parent_namespace]["classes"]:
                self._collect_props(self.model[parent_namespace]["classes"][parent_class], parent_namespace, True)

        for propname, propinfo in cls["properties"].items():
            propname = get_qualified_name(propname, namespace)
            proptype = get_qualified_name(propinfo["type"], namespace)
            optional = "minCount" not in propinfo or propinfo["minCount"] == "0"
            is_list = "maxCount" not in propinfo or propinfo["maxCount"] != "1"
            prop = Property(propname, proptype, optional, is_list, is_parent)
            self.props.append(prop)
            self._import_spdx_type(proptype)

            if proptype == "Core/DictionaryEntry":
                self._add_import("beartype.typing", "Dict")
                self._add_import("beartype.typing", "Optional")
            elif is_list:
                self._add_import("beartype.typing", "List")
            elif optional:
                self._add_import("beartype.typing", "Optional")

    def gen_file(self):
        properties = self._gen_props()
        constructor = self._gen_constructor()
        # imports should be last, as we may add additional types to import during generation
        imports = self._gen_imports()
        with open(self.file_path, "w") as output_file:
            output_file.write(CLS_FILE.format(typename=self.typename, parent=self.parent_class, docstring=self.docstring, properties=properties, imports=imports, constructor=constructor))

    def _gen_imports(self) -> str:
        imports = ""
        for module in sorted(self.imports.keys()):
            types = ", ".join(sorted(self.imports[module]))
            imports += CLS_IMPORTS.format(module=module, types=types)
        return imports

    def _gen_props(self) -> str:
        code = ""
        own_props = (prop for prop in self.props if not prop.inherited)
        for prop in own_props:
            default = ""
            name = prop_name_to_python(prop.name)
            proptype = prop.get_python_type()
            docstring = self._get_prop_docstring(prop.name)
            if prop.type == "Core/DictionaryType":
                default = " = field(default_factory=dict)"
                self._add_import("dataclasses", "field")
            elif prop.is_list:
                default = " = field(default_factory=list)"
                self._add_import("dataclasses", "field")
            elif prop.optional:
                default = " = None"
            code += CLS_PROP.format(prop_name=name, prop_type=proptype, default=default, docstring=docstring)
        return code

    def _get_prop_docstring(self, name: str) -> str:
        namespace, propname = split_qualified_name(name)
        if namespace not in self.model or "properties" not in self.model[namespace]:
            return ""
        prop = self.model[namespace]["properties"].get(propname)
        if not prop:
            return ""
        return get_python_docstring(prop["description"], 4)

    def _gen_constructor(self) -> str:
        if self.cls["metadata"].get("Instantiability") == "Abstract":
            self._add_import("abc", "abstractmethod")
            return CLS_INIT_ABSTRACT

        self._add_import("spdx_tools.common.typing.type_checks", "check_types_and_set_values")
        args = ""
        remaps = ""
        required_props = (prop for prop in self.props if not prop.optional)
        optional_props = (prop for prop in self.props if prop.optional)
        for prop in required_props:
            args += CLS_INIT_ARG.format(prop_name=prop_name_to_python(prop.name), prop_type=prop.get_python_type())
        for prop in optional_props:
            prop_name = prop_name_to_python(prop.name)
            args += CLS_INIT_ARG_OPT.format(prop_name=prop_name, prop_type=prop.get_python_type())
            if prop.type == "Core/DictionaryEntry":
                remaps += CLS_INIT_REMAP.format(prop_name=prop_name, default="{}")
            elif prop.is_list:
                remaps += CLS_INIT_REMAP.format(prop_name=prop_name, default="[]")
        return CLS_INIT.format(arguments=args, remaps=remaps)


class GenPythonModelFromSpec:
    namespace_imports: str
    init_imports: dict[str, dict[str, str]]

    def __init__(self):
        self.namespace_imports = ""
        self.init_imports = {}

    def create_namespace_import(self, model: dict):
        namespaces = [namespace_name_to_python(namespace["name"]) for namespace in model.values()]
        if namespaces:
            self.namespace_imports = "from . import " + ", ".join(namespaces)

    def handle_class(self, clazz: dict, namespace_name: str, model: dict):
        clsinfo = GenClassFromSpec(clazz, namespace_name, model)
        clsinfo.gen_file()

        if namespace_name not in self.init_imports:
            self.init_imports[namespace_name] = dict()
        self.init_imports[namespace_name][clsinfo.filename] = clsinfo.typename

    def handle_vocab(self, vocab: dict, namespace_name: str):
        typename = vocab["metadata"]["name"]
        python_typename = camel_case_to_snake_case(typename)
        values_text = "\n".join([VOCAB_ENTRY.format(value=camel_case_to_snake_case(value).upper(), docstring=get_python_docstring(description, 4)) for value, description in vocab["entries"].items()])
        values_to_str_text = "\n".join([VOCAB_VALUE_TO_STR.format(python_value=camel_case_to_snake_case(value).upper(), str_value=value, typename=typename) for value in vocab["entries"]])
        str_to_values_text = "\n".join([VOCAB_STR_TO_VALUE.format(python_value=camel_case_to_snake_case(value).upper(), str_value=value, typename=typename) for value in vocab["entries"]])
        docstring = get_python_docstring(vocab["description"], 4)
        file_path = get_file_path(typename, namespace_name)
        with open(file_path, "w") as output_file:
            output_file.write(VOCAB_FILE.format(typename=typename, values=values_text, values_to_str=values_to_str_text, str_to_values=str_to_values_text, python_typename=python_typename, docstring=docstring))

        if not namespace_name in self.init_imports:
            self.init_imports[namespace_name] = dict()
        self.init_imports[namespace_name][python_typename] = typename

    def handle_namespace(self, namespace: dict, model: dict):
        namespace_name = namespace["name"]
        namespace_path = os.path.join(output_dir, namespace_name_to_python(namespace_name))
        os.makedirs(namespace_path, exist_ok=True)
        for clazz in namespace["classes"].values():
            self.handle_class(clazz, namespace_name, model)
        for vocab in namespace["vocabs"].values():
            self.handle_vocab(vocab, namespace_name)

        if namespace_name in self.init_imports:
            with open(os.path.join(output_dir, namespace_name_to_python(namespace_name), "__init__.py"), "w") as init_file:
                init_file.write(FILE_HEADER)
                for module, typename in sorted(self.init_imports[namespace_name].items()):
                    init_file.write(f"from .{module} import {typename}\n")

    def run(self):
        os.makedirs(output_dir, exist_ok=True)
        Path(os.path.join(output_dir, "__init__.py")).touch()

        with open("model_dump.json") as model_file:
            model = json.load(model_file)

        self.create_namespace_import(model)

        for namespace in model.values():
            self.handle_namespace(namespace, model)

        with open(os.path.join(output_dir, "__init__.py"), "w") as init_file:
            init_file.write(FILE_HEADER)
            namespace_imports = ", ".join([namespace_name_to_python(namespace) for namespace in self.init_imports.keys()])
            init_file.write(f"from . import {namespace_imports}\n")
            init_file.write("from .core import *\n")


if __name__ == "__main__":
    GenPythonModelFromSpec().run()
