# SPDX-FileCopyrightText: 2023 spdx contributors
#
# SPDX-License-Identifier: Apache-2.0

"""
Auto-generates the python model representation from the SPDX3 model spec.

Usage: fetch a fresh copy of the spdx-3-model and the spec-parser, then generate a json dump of the model with
the spec-parser:

    python main.py --json-dump ../spdx-3-model/model

Copy the generated `model_dump.json` in `md_generated` next to this file, then run it:

    python gen_python_model_from_spec.py

Commit resulting changes.
"""

import json
import os.path
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import IO, Optional

from spdx_tools.spdx.casing_tools import camel_case_to_snake_case

FILE_HEADER = """# SPDX-License-Identifier: Apache-2.0
#
# This file was auto-generated by dev/gen_python_model_from_spec.py
# Do not manually edit!

"""

VOCAB_FILE = FILE_HEADER + """from beartype.typing import Optional
from enum import Enum, auto


class {typename}(Enum):{docstring}

{values}

    def __str__(self) -> str:
{values_to_str}
        return "unknown"

    @staticmethod
    def from_str(value: str) -> Optional['{typename}']:
{str_to_values}
        return None
"""

VOCAB_ENTRY = "    {value} = auto(){docstring}"

VOCAB_VALUE_TO_STR = "        if self == {typename}.{python_value}:\n            return \"{str_value}\""

VOCAB_STR_TO_VALUE = "        if value == \"{str_value}\":\n            return {typename}.{python_value}"

CLS_FILE = FILE_HEADER + """{imports}
from spdx_tools.common.typing.dataclass_with_properties import dataclass_with_properties


@dataclass_with_properties
class {typename}({parent}):{docstring}

{properties}
"""

CLS_IMPORTS = "from {module} import {types}\n"
CLS_PROP = "    {prop_name}: {prop_type}{default}{docstring}\n"

FINAL_LINE = """# fmt: on
"""

output_dir = os.path.join(os.path.dirname(__file__), "../src/spdx_tools/spdx3/new_model")


def prop_name_to_python(prop_name: str):
    special_cases = {"from": "from_element", "homePage": "homepage"}
    _, prop_name = split_qualified_name(prop_name)
    if prop_name in special_cases:
        return special_cases[prop_name]
    return camel_case_to_snake_case(prop_name)


def namespace_name_to_python(namespace_name: str):
    special_cases = {"AI": "ai"}
    if namespace_name in special_cases:
        return special_cases[namespace_name]
    return camel_case_to_snake_case(namespace_name)


def get_file_path(typename: str, namespace: str) -> str:
    namespace = namespace_name_to_python(namespace)
    typename = camel_case_to_snake_case(typename)
    return os.path.join(output_dir, namespace, f"{typename}.py")


def get_python_docstring(description: Optional[str], indent: int) -> str:
    if not description:
        return ""

    line_length = 120 - indent
    text = textwrap.fill(description, line_length, replace_whitespace=False)
    text = '\n"""\n' + text + '\n"""'
    return textwrap.indent(text, ' ' * indent)


def get_qualified_name(name: str, namespace: str):
    if name.startswith('/'):
        name = name[1:]
    if name.startswith("xsd:"):
        return name
    if '/' in name:
        return name
    return f"{namespace}/{name}"


def split_qualified_name(typename: str) -> tuple[str, str]:
    if '/' not in typename:
        return "", typename
    namespace, _, typename = typename.partition('/')
    return namespace, typename


def to_python_type(typename: str) -> str:
    if typename == "xsd:datetime" or typename == "Core/DateTime":
        return "datetime"
    if typename == "Core/SemVer":
        return "str"
    if typename.startswith("xsd:"):
        return "str"
    _, typename = split_qualified_name(typename)
    return typename


def extract_parent_type(cls: dict, namespace: str) -> Optional[str]:
    parent_class = cls["metadata"].get("SubclassOf") or "none"
    if parent_class == "none":
        return None
    return get_qualified_name(parent_class, namespace)


@dataclass
class Property:
    name: str
    type: str
    optional: bool
    is_list: bool
    inherited: bool


class GenClassFromSpec:
    cls: dict
    model: dict

    typename: str
    namespace: str
    filename: str
    file_path: str
    parent_class: str
    docstring: str
    # module -> types
    imports: dict[str, set[str]]
    props: list[Property]

    def __init__(self, cls: dict, namespace: str, model: dict):
        self.cls = cls
        self.namespace = namespace
        self.model = model
        self.imports = dict()
        self.props = list()

        self.typename = cls["metadata"]["name"]
        self.filename = camel_case_to_snake_case(self.typename)
        parent_class = extract_parent_type(cls, namespace)
        if not parent_class:
            self.parent_class = "ABC"
            self._add_import("abc", "ABC")
        else:
            self.parent_class = to_python_type(parent_class)
            self._import_spdx_type(parent_class)
        self.docstring = get_python_docstring(cls["description"], 4)
        self.file_path = get_file_path(self.typename, namespace)

        self._collect_props(self.cls, self.namespace, False)

    def _add_import(self, module: str, typename: str):
        if module not in self.imports:
            self.imports[module] = set()
        self.imports[module].add(typename)

    def _import_spdx_type(self, typename: str):
        if typename == "Core/DateTime":
            self._add_import("datetime", "datetime")
            return
        if typename == "Core/SemVer":
            return
        if typename.startswith("xsd:"):
            return
        namespace, typename = split_qualified_name(typename)
        namespace = f"..{namespace_name_to_python(namespace)}"
        self._add_import(namespace, typename)

    def _collect_props(self, cls: dict, namespace: str, is_parent: bool):
        parent = extract_parent_type(cls, namespace)
        if parent:
            parent_namespace, parent_class = split_qualified_name(parent)
            if parent_namespace in self.model and parent_class in self.model[parent_namespace]["classes"]:
                self._collect_props(self.model[parent_namespace]["classes"][parent_class], parent_namespace, True)

        for propname, propinfo in cls["properties"].items():
            propname = get_qualified_name(propname, namespace)
            proptype = get_qualified_name(propinfo["type"], namespace)
            optional = "minCount" not in propinfo or propinfo["minCount"] == "0"
            is_list = "maxCount" not in propinfo or propinfo["maxCount"] != "1"
            prop = Property(propname, proptype, optional, is_list, is_parent)
            self.props.append(prop)
            self._import_spdx_type(proptype)

    def gen_file(self):
        properties = self._gen_props()
        # imports should be last, as we may add additional types to import during generation
        imports = self._gen_imports()
        with open(self.file_path, "w") as output_file:
            output_file.write(CLS_FILE.format(typename=self.typename, parent=self.parent_class, docstring=self.docstring, properties=properties, imports=imports))

    def _gen_imports(self) -> str:
        imports = ""
        for module in sorted(self.imports.keys()):
            types = ", ".join(sorted(self.imports[module]))
            imports += CLS_IMPORTS.format(module=module, types=types)
        return imports

    def _gen_props(self) -> str:
        code = ""
        own_props = (prop for prop in self.props if not prop.inherited)
        for prop in own_props:
            default = ""
            name = prop_name_to_python(prop.name)
            proptype = to_python_type(prop.type)
            docstring = self._get_prop_docstring(prop.name)
            if prop.is_list:
                proptype = f"List[{proptype}]"
                default = " = field(default_factory=list)"
                self._add_import("beartype.typing", "List")
                self._add_import("dataclasses", "field")
            elif prop.optional:
                proptype = f"Optional[{proptype}]"
                default = " = None"
                self._add_import("beartype.typing", "Optional")
            code += CLS_PROP.format(prop_name=name, prop_type=proptype, default=default, docstring=docstring)
        return code

    def _get_prop_docstring(self, name: str) -> str:
        namespace, propname = split_qualified_name(name)
        if namespace not in self.model or "properties" not in self.model[namespace]:
            return ""
        prop = self.model[namespace]["properties"].get(propname)
        if not prop:
            return ""
        return get_python_docstring(prop["description"], 4)


class GenPythonModelFromSpec:
    prop_name_to_id: dict[str, str]
    class_to_converter_func: dict[str, str]
    namespace_imports: str
    init_imports: dict[str, dict[str, str]]

    def __init__(self):
        self.prop_name_to_id = {}
        self.class_to_converter_func = {}
        self.namespace_imports = ""
        self.init_imports = {}

    def create_namespace_import(self, model: dict):
        namespaces = [namespace_name_to_python(namespace["name"]) for namespace in model.values()]
        if namespaces:
            self.namespace_imports = "from . import " + ", ".join(namespaces)

    def map_prop_names_to_ids(self, model: dict):
        for namespace in model.values():
            namespace_name = namespace["name"]
            for prop_name, prop in namespace["properties"].items():
                full_prop_name = f"{namespace_name}/{prop_name}"
                prop_id = prop["metadata"]["id"]
                self.prop_name_to_id[full_prop_name] = prop_id

    def is_literal_type(self, typename: str, namespace_name: str, model: dict) -> bool:
        if typename.startswith('/'):
            typename = typename[1:]
        if typename.startswith("xsd:"):
            return True
        if '/' in typename:
            namespace_name, _, typename = typename.partition('/')
        namespace = model[namespace_name] if namespace_name in model else None
        if namespace and typename in namespace["vocabs"]:
            return False
        clazz = namespace["classes"][typename] if namespace and typename in namespace["classes"] else None
        if not clazz:
            return True
        if "SubclassOf" not in clazz["metadata"] or clazz["metadata"]["SubclassOf"] == "none" or clazz["metadata"]["SubclassOf"].startswith("xsd:"):
            return not clazz["properties"]
        return False

    def get_type_uri(self, typename: str, namespace_name: str) -> str:
        if typename.startswith('/'):
            typename = typename[1:]
        if typename.startswith("xsd:"):
            return typename.replace("xsd:", "http://www.w3.org/2001/XMLSchema#")
        if '/' in typename:
            namespace_name, _, typename = typename.partition('/')
        return f"https://spdx.org/rdf/v3/{namespace_name}/{typename}"

    def prop_conversion_code(self, typename: str, namespace_name: str, model: dict) -> str:
        if self.is_literal_type(typename, namespace_name, model):
            return f"Literal(value, datatype=\"{self.get_type_uri(typename, namespace_name)}\")"
        return "model_to_rdf(value, graph)"

    def handle_class(self, clazz: dict, namespace_name: str, model: dict):
        clsinfo = GenClassFromSpec(clazz, namespace_name, model)
        clsinfo.gen_file()

        if namespace_name not in self.init_imports:
            self.init_imports[namespace_name] = dict()
        self.init_imports[namespace_name][clsinfo.filename] = clsinfo.typename

    def handle_vocab(self, vocab: dict, namespace_name: str):
        typename = vocab["metadata"]["name"]
        python_typename = camel_case_to_snake_case(typename)
        values_text = "\n".join([VOCAB_ENTRY.format(value=camel_case_to_snake_case(value).upper(), docstring=get_python_docstring(description, 4)) for value, description in vocab["entries"].items()])
        values_to_str_text = "\n".join([VOCAB_VALUE_TO_STR.format(python_value=camel_case_to_snake_case(value).upper(), str_value=value, typename=typename) for value in vocab["entries"]])
        str_to_values_text = "\n".join([VOCAB_STR_TO_VALUE.format(python_value=camel_case_to_snake_case(value).upper(), str_value=value, typename=typename) for value in vocab["entries"]])
        docstring = get_python_docstring(vocab["description"], 4)
        file_path = get_file_path(typename, namespace_name)
        with open(file_path, "w") as output_file:
            output_file.write(VOCAB_FILE.format(typename=typename, values=values_text, values_to_str=values_to_str_text, str_to_values=str_to_values_text, python_typename=python_typename, docstring=docstring))

        if not namespace_name in self.init_imports:
            self.init_imports[namespace_name] = dict()
        self.init_imports[namespace_name][python_typename] = typename

    def handle_namespace(self, namespace: dict, model: dict):
        namespace_name = namespace["name"]
        namespace_path = os.path.join(output_dir, namespace_name_to_python(namespace_name))
        os.makedirs(namespace_path, exist_ok=True)
        for clazz in namespace["classes"].values():
            self.handle_class(clazz, namespace_name, model)
        for vocab in namespace["vocabs"].values():
            self.handle_vocab(vocab, namespace_name)

        if namespace_name in self.init_imports:
            with open(os.path.join(output_dir, namespace_name_to_python(namespace_name), "__init__.py"), "w") as init_file:
                init_file.write(FILE_HEADER)
                for module, typename in sorted(self.init_imports[namespace_name].items()):
                    init_file.write(f"from .{module} import {typename}\n")

    def run(self):
        os.makedirs(output_dir, exist_ok=True)
        Path(os.path.join(output_dir, "__init__.py")).touch()

        with open("model_dump.json") as model_file:
            model = json.load(model_file)

        self.create_namespace_import(model)
        self.map_prop_names_to_ids(model)

        for namespace in model.values():
            self.handle_namespace(namespace, model)

        with open(os.path.join(output_dir, "__init__.py"), "w") as init_file:
            init_file.write(FILE_HEADER)
            namespace_imports = ", ".join([namespace_name_to_python(namespace) for namespace in self.init_imports.keys()])
            init_file.write(f"from . import {namespace_imports}\n")
            init_file.write("from .core import *\n")


if __name__ == "__main__":
    GenPythonModelFromSpec().run()
