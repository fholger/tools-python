# SPDX-License-Identifier: Apache-2.0
#
# This file was auto-generated by dev/gen_python_model_from_spec.py
# Do not manually edit!
# flake8: noqa

from dataclasses import field

from beartype.typing import List, Optional

from spdx_tools.common.typing.dataclass_with_properties import dataclass_with_properties
from spdx_tools.common.typing.type_checks import check_types_and_set_values

from ..core.creation_info import CreationInfo
from ..core.external_identifier import ExternalIdentifier
from ..core.external_reference import ExternalReference
from ..core.integrity_method import IntegrityMethod
from ..licensing.any_license_info import AnyLicenseInfo


@dataclass_with_properties
class DisjunctiveLicenseSet(AnyLicenseInfo):
    """
    A DisjunctiveLicenseSet indicates that _only one_ of its subsidiary AnyLicenseInfos is required to apply. In other
    words, a DisjunctiveLicenseSet of two or more licenses represents a licensing situation where _only one_ of the
    specified licenses are to be complied with. A consumer of SPDX data would typically understand this to permit the
    recipient of the licensed content to choose which of the corresponding license they would prefer to use. It is
    represented in the SPDX License Expression Syntax by the `OR` operator.
    """

    member: List[AnyLicenseInfo] = field(default_factory=list)
    """
    A member is a license expression participating in a conjuctive (of type ConjunctiveLicenseSet) or a disjunctive (of
    type DisjunctiveLicenseSet) license set.
    """

    def __init__(
        self,
        spdx_id: str,
        creation_info: CreationInfo,
        member: List[AnyLicenseInfo],
        name: Optional[str] = None,
        summary: Optional[str] = None,
        description: Optional[str] = None,
        comment: Optional[str] = None,
        verified_using: List[IntegrityMethod] = None,
        external_reference: List[ExternalReference] = None,
        external_identifier: List[ExternalIdentifier] = None,
        extension: List[str] = None,
    ):
        verified_using = [] if verified_using is None else verified_using
        external_reference = [] if external_reference is None else external_reference
        external_identifier = [] if external_identifier is None else external_identifier
        extension = [] if extension is None else extension
        check_types_and_set_values(self, locals())
